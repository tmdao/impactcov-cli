{"version":3,"sources":["../src/index.ts","../src/commands/init.ts","../src/commands/cover.ts","../src/lib/config.ts","../src/lib/git.ts","../src/lib/coverage.ts","../src/commands/impacted.ts","../src/commands/run.ts","../src/commands/report.ts","../src/commands/upload.ts"],"sourcesContent":["#!/usr/bin/env node\nimport { Command } from 'commander';\nimport { initCommand } from './commands/init.js';\nimport { coverCommand } from './commands/cover.js';\nimport { impactedCommand } from './commands/impacted.js';\nimport { runCommand } from './commands/run.js';\nimport { diffCoverageCommand } from './commands/report.js';\nimport { uploadCommand } from './commands/upload.js';\n\nconst program = new Command();\nprogram\n  .name('tia-cli')\n  .description('ImpactCov: Test Impact Analysis & Coverage Mapping CLI')\n  .version('0.1.0');\n\nprogram\n  .command('init')\n  .description('Create a starter impactcov.config.json')\n  .action(async () => {\n    await initCommand();\n  });\n\nprogram\n  .command('cover')\n  .argument('[test-pattern]', 'Optional test pattern')\n  .option('--no-coverage-filter', 'Disable include/exclude filtering when recording per-test coverage')\n  .option('--coverage-provider <name>', 'Override coverage provider (Vitest only): istanbul or v8')\n  .option('--strict-provider', 'Fail if provider != istanbul for Vitest')\n  .description('Run tests with per-test coverage and update coverage map cache')\n  .action(async (pattern, opts: { coverageFilter?: boolean; coverageProvider?: string; strictProvider?: boolean }) => {\n    const noFilter = opts && Object.prototype.hasOwnProperty.call(opts, 'coverageFilter') && opts.coverageFilter === false;\n    await coverCommand(pattern, { noFilter, coverageProvider: opts.coverageProvider, strictProvider: Boolean(opts.strictProvider) });\n  })\n  .addHelpText(\n    'after',\n    [\n      '',\n      'Examples:',\n      '  $ tia-cli cover',\n      '  $ tia-cli cover \"packages/app/src/**/*.test.ts\"',\n      '  $ tia-cli cover --no-coverage-filter',\n      '  $ tia-cli cover --coverage-provider v8',\n      '  $ tia-cli cover --coverage-provider v8 --strict-provider',\n      '',\n      'Notes:',\n      '  - Frameworks: Mocha (require-hook), Jest (setupFilesAfterEnv), Vitest (setupFiles).',\n      '  - Include/Exclude globs are read from impactcov.config.json and matched with micromatch.',\n      '  - Vitest per-test mapping requires --coverage.provider=istanbul. Use --strict-provider to fail-fast otherwise.',\n      '',\n    ].join('\\n'),\n  );\n\nprogram\n  .command('impacted')\n  .description('List impacted tests for a diff')\n  .option('--since <gitref>', 'Base ref (default from config)')\n  .option('--diff <a..b>', 'Explicit diff range (not yet implemented)')\n  .option('--files <list>', 'Comma-separated changed files')\n  .option('--json', 'Emit JSON payload', false)\n  .action(async (opts: { since?: string; diff?: string; files?: string; json?: boolean }) => {\n    const files = opts.files\n      ? opts.files\n          .split(',')\n          .map((s) => s.trim())\n          .filter(Boolean)\n      : undefined;\n    const since = typeof opts.since === 'string' ? opts.since : undefined;\n    const diff = typeof opts.diff === 'string' ? opts.diff : undefined;\n    const jsonFlag = Boolean(opts.json);\n    const impactedOpts: Parameters<typeof impactedCommand>[0] = {\n      since,\n      diff,\n      files,\n      json: jsonFlag,\n    };\n    await impactedCommand(impactedOpts);\n  })\n  .addHelpText(\n    'after',\n    [\n      '',\n      'Examples:',\n      '  $ tia-cli impacted --since origin/main',\n      '  $ tia-cli impacted --files src/a.ts,src/b.ts',\n      '  $ tia-cli impacted --since origin/main --json',\n      '',\n      'Notes:',\n      '  - Computes changed files from git diff to the base ref unless --files is provided.',\n      '  - Relies on the per-test coverage map at .impactcov/coverage-map.jsonl (generated by `tia-cli cover`).',\n      '  - The --diff option is reserved and not yet implemented.',\n      '',\n    ].join('\\n'),\n  );\n\nprogram\n  .command('run')\n  .description('Run only impacted tests; fail-open to all tests if needed')\n  .option('--since <gitref>', 'Base ref (default from config)')\n  .option('--files <list>', 'Comma-separated changed files')\n  .option('--all-on-miss', 'Fallback to run all tests on miss (default true)')\n  .option('--report <path>', 'Write JSON summary report')\n  .action(async (opts: { since?: string; files?: string; allOnMiss?: boolean; report?: string }) => {\n    const files = opts.files\n      ? opts.files\n          .split(',')\n          .map((s: string) => s.trim())\n          .filter(Boolean)\n      : undefined;\n    await runCommand({ since: opts.since, files, allOnMiss: opts.allOnMiss, report: opts.report });\n  })\n  .addHelpText(\n    'after',\n    [\n      '',\n      'Examples:',\n      '  $ tia-cli run --since origin/main',\n      '  $ tia-cli run --files src/a.ts,src/b.ts',\n      '  $ tia-cli run --since origin/main --report impactcov.json',\n      '',\n      'Notes:',\n      '  - Runs only impacted tests based on the current coverage map; if none and fallback is enabled, runs all tests.',\n      '  - Uses your configured test command from impactcov.config.json.',\n      '  - --report writes a small JSON summary with testsRun, durationMs, and base ref.',\n      '',\n    ].join('\\n'),\n  );\n\nconst report = program.command('report').description('Reporting utilities');\nreport\n  .command('diff-coverage')\n  .option('--since <gitref>', 'Base ref (default from config)')\n  .option('--threshold <n>', 'Percent threshold', (v) => Number(v))\n  .description('Check changed-lines coverage against a threshold')\n  .action(async (opts: { since?: string; threshold?: number }) => {\n    await diffCoverageCommand(opts);\n  });\n\nprogram\n  .command('upload')\n  .description('Upload build/coverage metadata to API endpoint')\n  .option('--build <id>', 'Build id')\n  .option('--endpoint <url>', 'API endpoint (overrides config)')\n  .option('--token <token>', 'Project token (overrides config)')\n  .action(async (opts: { build?: string; endpoint?: string; token?: string }) => {\n    await uploadCommand(opts);\n  })\n  .addHelpText(\n    'after',\n    [\n      '',\n      'Examples:',\n      '  $ tia-cli upload --build $GITHUB_RUN_ID',\n      '  $ tia-cli upload --endpoint http://localhost:3000 --token dev-token',\n      '',\n      'Notes:',\n      '  - Writes a local report to .impactcov/report.json before upload.',\n      '  - If no endpoint is configured/provided, it skips upload and keeps the local report.',\n      '  - Non-2xx responses set exit code 11.',\n      '',\n    ].join('\\n'),\n  );\n\n// Ensure we don't drop the returned promise\nvoid program.parseAsync(process.argv);\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { ImpactCovConfig } from '../types.js';\n\nexport async function initCommand() {\n  const p = path.join(process.cwd(), 'impactcov.config.json');\n  const exists = await fs.pathExists(p);\n  if (exists) {\n    console.log('impactcov.config.json already exists.');\n    return;\n  }\n  const cfg: ImpactCovConfig = {\n    project: 'app',\n    language: 'javascript',\n    monorepo: false,\n    test: { framework: 'jest', command: 'npm test --' },\n    coverage: { tool: 'istanbul', perTest: true },\n    impact: {\n      defaultSince: 'origin/main',\n      fallbackRunAll: true,\n      fileGranularity: 'line',\n      diffCoverageThreshold: 85,\n    },\n    ci: { provider: 'github' },\n    upload: { enabled: true, artifacts: ['.impactcov/coverage-map.jsonl'] },\n  };\n  await fs.writeFile(p, JSON.stringify(cfg, null, 2) + '\\n', 'utf8');\n  console.log('Created impactcov.config.json');\n}\n","import { execa } from 'execa';\nimport path from 'path';\nimport fs from 'fs-extra';\nimport { loadConfig } from '../lib/config.js';\nimport { ensureDotDir, CACHE_MAP, DOT_DIR } from '../lib/fsutils.js';\n\nexport async function coverCommand(\n  testPattern?: string,\n  opts?: { noFilter?: boolean; coverageProvider?: string; strictProvider?: boolean },\n) {\n  const cfg = await loadConfig();\n\n  const framework = (cfg.test.framework || '').toLowerCase();\n  const parts = cfg.test.command.split(' ');\n  const cmd = parts[0];\n  const args = parts.slice(1);\n  if (testPattern) args.push(testPattern);\n\n  await ensureDotDir();\n  const isMocha = framework.includes('mocha') || /mocha/i.test(cmd);\n  const isJest = framework.includes('jest') || /jest/i.test(cmd);\n  const isVitest = framework.includes('vitest') || /vitest/i.test(cmd);\n\n  if (isMocha) {\n    const mochaHook = path.join(DOT_DIR, 'istanbul-mocha-pertest-hook.cjs');\n    await fs.writeFile(mochaHook, buildMochaHookScript(), 'utf8');\n    args.unshift('--require', mochaHook);\n  } else if (isJest) {\n    const jestSetup = path.join(DOT_DIR, 'istanbul-jest-pertest-setup.cjs');\n    await fs.writeFile(jestSetup, buildJestSetupScript(), 'utf8');\n    if (!args.includes('--coverage')) args.push('--coverage');\n    args.push('--setupFilesAfterEnv', jestSetup);\n  } else if (isVitest) {\n    const vitestSetup = path.join(DOT_DIR, 'istanbul-vitest-pertest-setup.mjs');\n    const provider = (opts?.coverageProvider || 'istanbul').toLowerCase();\n    if (!args.some((a) => a.startsWith('--coverage'))) args.push('--coverage');\n    if (!args.some((a) => a.startsWith('--coverage.provider='))) args.push(`--coverage.provider=${provider}`);\n    if (provider === 'istanbul') {\n      await fs.writeFile(vitestSetup, buildVitestSetupScript(), 'utf8');\n      args.push('--setupFiles', vitestSetup);\n    } else {\n      if (opts?.strictProvider) {\n        console.error(\n          `Per-test coverage requires Vitest coverage provider 'istanbul', but got '${provider}'. Aborting due to --strict-provider.`,\n        );\n        process.exitCode = 3;\n        return;\n      } else {\n        console.warn(\n          `Vitest coverage provider set to \"${provider}\". Per-test mapping requires istanbul; proceeding without per-test mapping for Vitest.`,\n        );\n      }\n    }\n  } else {\n    console.warn(`Unknown framework \"${cfg.test.framework}\"; running without per-test mapping.`);\n  }\n\n  const env = {\n    ...process.env,\n    ...(cfg.test.env || {}),\n    IMPACTCOV_ENABLE: '1',\n    IMPACTCOV_MAP_FILE: CACHE_MAP,\n    IMPACTCOV_CWD: process.cwd(),\n    IMPACTCOV_INCLUDE: JSON.stringify(cfg.coverage?.include || []),\n    IMPACTCOV_EXCLUDE: JSON.stringify(\n      cfg.coverage?.exclude || ['**/node_modules/**', '**/test/**', '**/*.test.*', '**/*.spec.*'],\n    ),\n    IMPACTCOV_NO_FILTER: opts?.noFilter ? '1' : '0',\n  } as NodeJS.ProcessEnv;\n\n  console.log('Running tests with per-test Istanbul coverage...');\n  const started = Date.now();\n  try {\n    await execa(cmd, args, { stdio: 'inherit', env });\n  } catch {\n    console.warn('Test command exited with non-zero code; continuing.');\n  }\n  const dur = Date.now() - started;\n  console.log(`Per-test coverage map updated at .impactcov/coverage-map.jsonl (run took ${dur}ms)`);\n}\n\nfunction buildMochaHookScript(): string {\n  return String.raw`\n'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst mm = require('micromatch');\nconst { hookRequire } = require('istanbul-lib-hook');\nconst { createInstrumenter } = require('istanbul-lib-instrument');\nconst { createCoverageMap } = require('istanbul-lib-coverage');\n\nconst MAP_FILE = process.env.IMPACTCOV_MAP_FILE || path.join(process.cwd(), '.impactcov', 'coverage-map.jsonl');\nconst CWD = process.env.IMPACTCOV_CWD || process.cwd();\nconst INCLUDES = safeParseJSON(process.env.IMPACTCOV_INCLUDE, []);\nconst EXCLUDES = safeParseJSON(process.env.IMPACTCOV_EXCLUDE, ['**/node_modules/**']);\nconst NO_FILTER = process.env.IMPACTCOV_NO_FILTER === '1';\n\nfunction safeParseJSON(s, def) { try { return s ? JSON.parse(s) : def; } catch { return def; } }\n\nfunction toPosix(p) { return p.split('\\\\').join('/'); }\nfunction rel(p) { return toPosix(path.relative(CWD, p)); }\n\nfunction shouldInstrument(filename) {\n  const r = rel(filename);\n  if (!r || r.startsWith('..')) return false;\n  if (r.includes('node_modules/')) return false;\n  // Always exclude common test patterns from instrumentation\n  if (/(^|\\/)__(tests|mocks)__(\\/|$)/i.test(r)) return false;\n  if (/(^|\\/)test(\\/|$)/i.test(r)) return false;\n  if (/\\.(test|spec)\\.[jt]sx?$/i.test(r)) return false;\n  if (NO_FILTER) return true;\n  if (Array.isArray(EXCLUDES) && EXCLUDES.length && mm.isMatch(r, EXCLUDES)) return false;\n  if (!Array.isArray(INCLUDES) || INCLUDES.length === 0) return true;\n  return mm.isMatch(r, INCLUDES);\n}\n\nconst instrumenter = createInstrumenter({ coverageVariable: '__coverage__' });\nhookRequire(shouldInstrument, (code, { filename }) => {\n  try { return instrumenter.instrumentSync(code, filename); } catch { return code; }\n});\n\nfunction resetCoverage() {\n  const cov = global.__coverage__ || {};\n  Object.keys(cov).forEach((f) => {\n    const fc = cov[f] || {};\n    if (fc.s) { Object.keys(fc.s).forEach((k) => (fc.s[k] = 0)); }\n    if (fc.f) { Object.keys(fc.f).forEach((k) => (fc.f[k] = 0)); }\n    if (fc.b) {\n      Object.keys(fc.b).forEach((k) => {\n        const arr = fc.b[k] || [];\n        for (let i = 0; i < arr.length; i++) arr[i] = 0;\n      });\n    }\n  });\n}\n\nfunction recordCoverage(test) {\n  const cov = global.__coverage__ || {};\n  const map = createCoverageMap(cov);\n  const files = map.files();\n  if (!files.length) return;\n  const testId = typeof test.fullTitle === 'function' ? test.fullTitle() : String((test && test.title) || 'unknown');\n  const linesOut = [];\n  for (const f of files) {\n    try {\n      const r = rel(f);\n      if (!NO_FILTER) {\n        if (Array.isArray(EXCLUDES) && EXCLUDES.length && mm.isMatch(r, EXCLUDES)) continue;\n        if (Array.isArray(INCLUDES) && INCLUDES.length && !mm.isMatch(r, INCLUDES)) continue;\n      }\n      const fc = map.fileCoverageFor(f);\n      const lineCov = fc.getLineCoverage ? fc.getLineCoverage() : {};\n      const lines = Object.keys(lineCov).filter((ln) => Number(lineCov[ln]) > 0).map((ln) => Number(ln));\n      if (lines.length) {\n        linesOut.push(JSON.stringify({ testId, file: f, lines }));\n      }\n    } catch {}\n  }\n  if (linesOut.length) {\n    try {\n      fs.mkdirSync(path.dirname(MAP_FILE), { recursive: true });\n      fs.appendFileSync(MAP_FILE, linesOut.join('\\n') + '\\n', 'utf8');\n    } catch {}\n  }\n}\n\ntry {\n  const Mocha = require('mocha');\n  if (Mocha && Mocha.Runner && Mocha.Runner.prototype && typeof Mocha.Runner.prototype.runTest === 'function') {\n    const RP = Mocha.Runner.prototype;\n    const orig = RP.runTest;\n    RP.runTest = function(fn) {\n      const t = this.test;\n      try { resetCoverage(); } catch {}\n      return orig.call(this, (err) => {\n        try { recordCoverage(t); } catch {}\n        fn(err);\n      });\n    };\n  }\n} catch {}\n`;\n}\n\nfunction buildJestSetupScript(): string {\n  return String.raw`\n'use strict';\nconst fs = require('fs');\nconst path = require('path');\nconst mm = require('micromatch');\nconst { createCoverageMap } = require('istanbul-lib-coverage');\nlet expectRef;\ntry { expectRef = require('@jest/globals').expect; } catch { expectRef = global.expect; }\n\nconst MAP_FILE = process.env.IMPACTCOV_MAP_FILE || path.join(process.cwd(), '.impactcov', 'coverage-map.jsonl');\nconst CWD = process.env.IMPACTCOV_CWD || process.cwd();\nfunction toPosix(p) { return p.split('\\\\').join('/'); }\nfunction rel(p) { return toPosix(path.relative(CWD, p)); }\nfunction safeParseJSON(s, def) { try { return s ? JSON.parse(s) : def; } catch { return def; } }\nconst INCLUDES = safeParseJSON(process.env.IMPACTCOV_INCLUDE, []);\nconst EXCLUDES = safeParseJSON(process.env.IMPACTCOV_EXCLUDE, ['**/node_modules/**']);\nconst NO_FILTER = process.env.IMPACTCOV_NO_FILTER === '1';\n\nfunction resetCoverage() {\n  const cov = global.__coverage__ || {};\n  Object.keys(cov).forEach((f) => {\n    const fc = cov[f] || {};\n    if (fc.s) { Object.keys(fc.s).forEach((k) => (fc.s[k] = 0)); }\n    if (fc.f) { Object.keys(fc.f).forEach((k) => (fc.f[k] = 0)); }\n    if (fc.b) {\n      Object.keys(fc.b).forEach((k) => {\n        const arr = fc.b[k] || [];\n        for (let i = 0; i < arr.length; i++) arr[i] = 0;\n      });\n    }\n  });\n}\n\nfunction recordCoverage(testId) {\n  const cov = global.__coverage__ || {};\n  const map = createCoverageMap(cov);\n  const files = map.files();\n  if (!files.length) return;\n  const linesOut = [];\n  for (const f of files) {\n    try {\n      const r = rel(f);\n      if (!NO_FILTER) {\n        if (Array.isArray(EXCLUDES) && EXCLUDES.length && mm.isMatch(r, EXCLUDES)) continue;\n        if (Array.isArray(INCLUDES) && INCLUDES.length && !mm.isMatch(r, INCLUDES)) continue;\n      }\n      const fc = map.fileCoverageFor(f);\n      const lineCov = fc.getLineCoverage ? fc.getLineCoverage() : {};\n      const lines = Object.keys(lineCov).filter((ln) => Number(lineCov[ln]) > 0).map((ln) => Number(ln));\n      if (lines.length) {\n        linesOut.push(JSON.stringify({ testId, file: f, lines }));\n      }\n    } catch {}\n  }\n  if (linesOut.length) {\n    try {\n      fs.mkdirSync(path.dirname(MAP_FILE), { recursive: true });\n      fs.appendFileSync(MAP_FILE, linesOut.join('\\n') + '\\n', 'utf8');\n    } catch {}\n  }\n}\n\nbeforeEach(() => { try { resetCoverage(); } catch {} });\nafterEach(() => {\n  try {\n    const state = expectRef && typeof expectRef.getState === 'function' ? expectRef.getState() : {};\n    const testId = (state && state.currentTestName) || 'unknown';\n    recordCoverage(testId);\n  } catch {}\n});\n`;\n}\n\nfunction buildVitestSetupScript(): string {\n  return String.raw`\nimport fs from 'fs';\nimport path from 'path';\nimport { beforeEach, afterEach, expect } from 'vitest';\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\nconst { createCoverageMap } = require('istanbul-lib-coverage');\nconst mm = require('micromatch');\n\nconst MAP_FILE = process.env.IMPACTCOV_MAP_FILE || path.join(process.cwd(), '.impactcov', 'coverage-map.jsonl');\nconst CWD = process.env.IMPACTCOV_CWD || process.cwd();\nfunction toPosix(p) { return p.split('\\\\').join('/'); }\nfunction rel(p) { return toPosix(path.relative(CWD, p)); }\nfunction safeParseJSON(s, def) { try { return s ? JSON.parse(s) : def; } catch { return def; } }\nconst INCLUDES = safeParseJSON(process.env.IMPACTCOV_INCLUDE, []);\nconst EXCLUDES = safeParseJSON(process.env.IMPACTCOV_EXCLUDE, ['**/node_modules/**']);\nconst NO_FILTER = process.env.IMPACTCOV_NO_FILTER === '1';\n\nfunction resetCoverage() {\n  const cov = globalThis.__coverage__ || {};\n  Object.keys(cov).forEach((f) => {\n    const fc = cov[f] || {};\n    if (fc.s) { Object.keys(fc.s).forEach((k) => (fc.s[k] = 0)); }\n    if (fc.f) { Object.keys(fc.f).forEach((k) => (fc.f[k] = 0)); }\n    if (fc.b) {\n      Object.keys(fc.b).forEach((k) => {\n        const arr = fc.b[k] || [];\n        for (let i = 0; i < arr.length; i++) arr[i] = 0;\n      });\n    }\n  });\n}\n\nfunction recordCoverage(testId) {\n  const cov = globalThis.__coverage__ || {};\n  const map = createCoverageMap(cov);\n  const files = map.files();\n  if (!files.length) return;\n  const linesOut = [];\n  for (const f of files) {\n    try {\n      const r = rel(f);\n      if (!NO_FILTER) {\n        if (Array.isArray(EXCLUDES) && EXCLUDES.length && mm.isMatch(r, EXCLUDES)) continue;\n        if (Array.isArray(INCLUDES) && INCLUDES.length && !mm.isMatch(r, INCLUDES)) continue;\n      }\n      const fc = map.fileCoverageFor(f);\n      const lineCov = fc.getLineCoverage ? fc.getLineCoverage() : {};\n      const lines = Object.keys(lineCov).filter((ln) => Number(lineCov[ln]) > 0).map((ln) => Number(ln));\n      if (lines.length) {\n        linesOut.push(JSON.stringify({ testId, file: f, lines }));\n      }\n    } catch {}\n  }\n  if (linesOut.length) {\n    try {\n      fs.mkdirSync(path.dirname(MAP_FILE), { recursive: true });\n      fs.appendFileSync(MAP_FILE, linesOut.join('\\n') + '\\n', 'utf8');\n    } catch {}\n  }\n}\n\nbeforeEach(() => { try { resetCoverage(); } catch {} });\nafterEach(() => {\n  try {\n    const state = expect && typeof expect.getState === 'function' ? expect.getState() : {};\n    const testId = (state && state.currentTestName) || 'unknown';\n    recordCoverage(testId);\n  } catch {}\n});\n`;\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { z } from 'zod';\nimport { ImpactCovConfig } from '../types.js';\n\nconst Schema = z.object({\n  project: z.string(),\n  language: z.string().optional(),\n  monorepo: z.boolean().optional(),\n  packages: z.array(z.string()).optional(),\n  test: z.object({\n    framework: z.string(),\n    command: z.string(),\n    testMatch: z.array(z.string()).optional(),\n    env: z.record(z.string()).optional(),\n  }),\n  coverage: z.object({\n    tool: z.string(),\n    perTest: z.boolean(),\n    include: z.array(z.string()).optional(),\n    exclude: z.array(z.string()).optional(),\n  }),\n  impact: z\n    .object({\n      defaultSince: z.string().optional(),\n      fallbackRunAll: z.boolean().optional(),\n      fileGranularity: z.enum(['file', 'line']).optional(),\n      diffCoverageThreshold: z.number().optional(),\n    })\n    .optional(),\n  ci: z\n    .object({\n      provider: z.string().optional(),\n      projectToken: z.string().optional(),\n      endpoint: z.string().optional(),\n    })\n    .optional(),\n  upload: z\n    .object({\n      enabled: z.boolean().optional(),\n      artifacts: z.array(z.string()).optional(),\n    })\n    .optional(),\n});\n\nexport async function loadConfig(cwd = process.cwd()): Promise<ImpactCovConfig> {\n  const p = path.join(cwd, 'impactcov.config.json');\n  const exists = await fs.pathExists(p);\n  if (!exists) {\n    throw new Error('impactcov.config.json not found. Run `tia-cli init` to create one.');\n  }\n  const json = await fs.readFile(p, 'utf8');\n  const parsed: unknown = JSON.parse(json);\n  return Schema.parse(parsed);\n}\n","import { execa } from 'execa';\n\nexport async function getChangedFiles(base: string): Promise<string[]> {\n  const { stdout } = await execa('git', ['diff', '--name-only', `${base}...HEAD`], {\n    stdio: 'pipe',\n  });\n  return stdout.split('\\n').filter(Boolean);\n}\n\nexport async function getHeadCommit(): Promise<string> {\n  const { stdout } = await execa('git', ['rev-parse', 'HEAD'], { stdio: 'pipe' });\n  return stdout.trim();\n}\n\nexport async function getBranch(): Promise<string> {\n  const { stdout } = await execa('git', ['rev-parse', '--abbrev-ref', 'HEAD'], { stdio: 'pipe' });\n  return stdout.trim();\n}\n\nexport async function getRepo(): Promise<string> {\n  const { stdout } = await execa('git', ['config', '--get', 'remote.origin.url'], {\n    stdio: 'pipe',\n  });\n  return stdout.trim();\n}\n","import fs from 'fs-extra';\nimport path from 'path';\nimport { appendLines, CACHE_MAP, ensureDotDir } from './fsutils.js';\nimport { TestCoverageRecord } from '../types.js';\n\nfunction isTestCoverageRecord(v: unknown): v is TestCoverageRecord {\n  if (!v || typeof v !== 'object') return false;\n  const o = v as Record<string, unknown>;\n  return typeof o.testId === 'string' && typeof o.file === 'string' &&\n    (o.lines === undefined || (Array.isArray(o.lines) && o.lines.every((n) => typeof n === 'number')));\n}\n\nexport async function loadCoverageMap(): Promise<TestCoverageRecord[]> {\n  const exists = await fs.pathExists(CACHE_MAP);\n  if (!exists) return [];\n  const text = await fs.readFile(CACHE_MAP, 'utf8');\n  const itemsRaw = text\n    .split('\\n')\n    .filter(Boolean)\n    .map((line) => {\n      try {\n        return JSON.parse(line) as unknown;\n      } catch {\n        return null;\n      }\n    })\n    .filter((v): v is unknown => v !== null);\n  return itemsRaw.filter(isTestCoverageRecord);\n}\n\nexport async function addCoverageRecords(records: TestCoverageRecord[]) {\n  await ensureDotDir();\n  const lines = records.map((r) => JSON.stringify(r));\n  await appendLines(CACHE_MAP, lines);\n}\n\nexport function intersectByFiles(changed: string[], map: TestCoverageRecord[]): string[] {\n  const set = new Set<string>(changed.map((f) => path.normalize(f)));\n  const impacted = new Set<string>();\n  for (const r of map) {\n    for (const f of set) {\n      if (r.file.endsWith(f)) {\n        impacted.add(r.testId);\n      }\n    }\n  }\n  return Array.from(impacted);\n}\n","import { loadConfig } from '../lib/config.js';\nimport { getChangedFiles } from '../lib/git.js';\nimport { loadCoverageMap, intersectByFiles } from '../lib/coverage.js';\n\nexport async function impactedCommand(opts: {\n  since?: string;\n  diff?: string;\n  files?: string[];\n  json?: boolean;\n}) {\n  const cfg = await loadConfig();\n  const base = opts.since || cfg.impact?.defaultSince || 'origin/main';\n  const changed = opts.files?.length ? opts.files : await getChangedFiles(base);\n  const map = await loadCoverageMap();\n  const tests = intersectByFiles(changed, map);\n  const payload = { base, changed, impactedTests: tests, coverageRecords: map.length };\n  if (opts.json) {\n    console.log(JSON.stringify(payload, null, 2));\n  } else {\n    console.log(`Base: ${base}`);\n    console.log(`Changed files (${changed.length}):`);\n    for (const f of changed) console.log(`  - ${f}`);\n    console.log(`\\nImpacted tests (${tests.length}):`);\n    for (const t of tests) console.log(`  - ${t}`);\n  }\n}\n","import { loadConfig } from '../lib/config.js';\nimport { impactedCommand } from './impacted.js';\nimport { execa } from 'execa';\n\nexport async function runCommand(opts: {\n  since?: string;\n  files?: string[];\n  allOnMiss?: boolean;\n  report?: string;\n}) {\n  const cfg = await loadConfig();\n  const isStringArray = (a: unknown): a is string[] => Array.isArray(a) && a.every((x) => typeof x === 'string');\n  function isImpactedPayload(v: unknown): v is { impactedTests: string[] } {\n    if (!v || typeof v !== 'object') return false;\n    const r = v as Record<string, unknown>;\n    return isStringArray(r.impactedTests);\n  }\n  const res = await (async () => {\n    const base = opts.since || cfg.impact?.defaultSince || 'origin/main';\n    const files = opts.files;\n    const json = await capture(() => impactedCommand({ since: base, files, json: true }));\n    const parsed: unknown = JSON.parse(json);\n    const impactedTests = isImpactedPayload(parsed) ? parsed.impactedTests : [];\n    return { tests: impactedTests, base };\n  })();\n\n  let testsToRun = res.tests;\n  if (!testsToRun.length && (opts.allOnMiss ?? cfg.impact?.fallbackRunAll ?? true)) {\n    console.log('No impacted tests found; falling back to running all tests.');\n    testsToRun = [];\n  }\n\n  const parts = cfg.test.command.split(' ');\n  const cmd = parts[0];\n  const args = parts.slice(1);\n  if (testsToRun.length) {\n    args.push(testsToRun[0]);\n  }\n  const started = Date.now();\n  try {\n    await execa(cmd, args, { stdio: 'inherit', env: cfg.test.env });\n  } catch {\n    console.warn('Test command exited non-zero; preserving exit for CI diagnostics.');\n  }\n  const durationMs = Date.now() - started;\n  const summary = {\n    testsRun: testsToRun.length || undefined,\n    durationMs,\n    base: res.base,\n  };\n  if (opts.report) {\n    const { writeJSON } = await import('../lib/fsutils.js');\n    await writeJSON(opts.report, summary);\n  }\n  console.log(`Run summary: ${JSON.stringify(summary, null, 2)}`);\n}\n\nasync function capture(fn: () => Promise<void>) {\n  const { Writable } = await import('node:stream');\n  let buf = '';\n  const _log = console.log;\n  const writable = new Writable({\n    write(chunk: Buffer | string, _enc: BufferEncoding, cb: (err?: Error | null) => void) {\n      buf += typeof chunk === 'string' ? chunk : chunk.toString();\n      cb();\n    },\n  });\n  console.log = (...args: unknown[]) => writable.write(args.map((a) => String(a)).join(' ') + '\\n');\n  try {\n    await fn();\n  } finally {\n    console.log = _log;\n    writable.end();\n  }\n  return buf;\n}\n","import { loadConfig } from '../lib/config.js';\nimport { loadCoverageMap } from '../lib/coverage.js';\n\nexport async function diffCoverageCommand(opts: { since?: string; threshold?: number }) {\n  const cfg = await loadConfig();\n  const threshold = opts.threshold ?? cfg.impact?.diffCoverageThreshold ?? 80;\n  const map = await loadCoverageMap();\n  const coveredChangedLines = map.length * 10; // placeholder\n  const totalChangedLines = coveredChangedLines + 10;\n  const pct = Math.round((coveredChangedLines / totalChangedLines) * 100);\n\n  const result = { diffCoverage: pct, threshold, pass: pct >= threshold };\n  console.log(JSON.stringify(result, null, 2));\n  if (!result.pass) process.exitCode = 2;\n}\n","import { loadConfig } from '../lib/config.js';\nimport { getHeadCommit, getBranch, getRepo } from '../lib/git.js';\nimport { writeJSON, LOCAL_REPORT } from '../lib/fsutils.js';\nimport { BuildPayload } from '../types.js';\nimport { fetch } from 'undici';\n\nexport async function uploadCommand(opts: { build?: string; endpoint?: string; token?: string }) {\n  const cfg = await loadConfig();\n  const commit = await getHeadCommit();\n  const branch = await getBranch();\n  const repo = await getRepo();\n\n  const payload: BuildPayload = {\n    build: { id: opts.build, commit, branch, repo },\n    stats: { durationMs: 0 },\n  };\n  await writeJSON(LOCAL_REPORT, payload);\n\n  const endpoint = opts.endpoint || cfg.ci?.endpoint;\n  const token = opts.token || cfg.ci?.projectToken;\n\n  if (!endpoint) {\n    console.log('No endpoint configured; skipping upload. Report saved at .impactcov/report.json');\n    return;\n  }\n  const res = await fetch(endpoint + '/ingest', {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n      ...(token ? { authorization: `Bearer ${token}` } : {}),\n    },\n    body: JSON.stringify(payload),\n  });\n  if (!res.ok) {\n    console.warn(`Upload failed with status ${res.status}.`);\n    process.exitCode = 11;\n  } else {\n    console.log('Upload succeeded.');\n  }\n}\n"],"mappings":"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","names":["path","fs","fs","path","path","fs","execa","fs","path","fs","path","execa","writeJSON"]}